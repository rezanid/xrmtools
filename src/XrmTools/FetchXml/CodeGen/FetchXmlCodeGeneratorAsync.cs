namespace XrmTools.FetchXml.CodeGen;

using Community.VisualStudio.Toolkit;
using Microsoft.Language.Xml;
using Microsoft.VisualStudio;
using Microsoft.VisualStudio.Shell;
using Microsoft.VisualStudio.Shell.Generators;
using Microsoft.VisualStudio.Shell.Interop;
using Microsoft.VisualStudio.Threading;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

internal class FetchXmlCodeGeneratorAsync : IVsSingleFileGeneratorAsync
{
    async Task<GeneratorResult> IVsSingleFileGeneratorAsync.GenerateAsync(
        string inputFilePath,
        string inputFileContents, 
        string defaultNamespace, 
        Stream outputStream, 
        IVsGeneratorProgress generatorProgress, 
        CancellationToken cancellationToken)
    {
        if (outputStream == null) throw new ArgumentNullException(nameof(outputStream));
        if (string.IsNullOrWhiteSpace(inputFileContents))
        {
            await WriteAsync(outputStream, "// Empty FetchXML input.");
            return GeneratorResult.Success;
        }

        try
        {
            var model = await ParseFetchXmlAsync(inputFileContents, cancellationToken).ConfigureAwait(false);
            model.Raw = inputFileContents;

            // For now: emit a simple C# class that embeds the FetchXML and a JSON dump of the parsed model
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated/>");
            sb.AppendLine("// This file was generated by XrmTools FetchXmlCodeGenerator.");
            sb.AppendLine("namespace " + (string.IsNullOrWhiteSpace(defaultNamespace) ? "XrmTools.Generated" : defaultNamespace) + ";");
            sb.AppendLine("internal static class FetchXmlArtifact");
            sb.AppendLine("{");
            sb.AppendLine("    public const string Xml = @\"" + EscapeForVerbatim(inputFileContents) + "\";");
            var json = JsonConvert.SerializeObject(model, Formatting.Indented);
            sb.AppendLine("    public const string ModelJson = @\"" + EscapeForVerbatim(json) + "\";");
            sb.AppendLine("}");

            await WriteAsync(outputStream, sb.ToString());
            return GeneratorResult.Success;
        }
        catch (Exception ex)
        {
            await WriteAsync(outputStream, "// Error generating from FetchXML: " + ex.Message);
            // Return success to avoid generator infrastructure treating it as a hard failure.
            return GeneratorResult.Success;
        }
    }

    Task<string> IVsSingleFileGeneratorAsync.GetDefaultExtensionAsync(CancellationToken cancellationToken) => Task.FromResult(".g.cs");

    public async Task<GeneratorResult> GenerateAsync(
        FetchXmlDocument document,
        string inputFilePath, 
        string defaultNamespace,
        Stream outputStream,
        IVsGeneratorProgress generatorProgress,
        CancellationToken cancellationToken)
    {
        if (document == null) throw new ArgumentNullException(nameof(document));
        if (outputStream == null) throw new ArgumentNullException(nameof(outputStream));
        if (document.IsParsing)
        {
            // Wait for the current parse to complete
            //await document..WaitForParseAsync(cancellationToken).ConfigureAwait(false);
        }

        var docSyntax = document.XmlDocument;

        if (docSyntax == null || docSyntax.Root == null)
        {
            await WriteAsync(outputStream, "// Unable to generate code: FetchXML could not be parsed.");
            return GeneratorResult.Success;
        }
        var fetchElement = docSyntax.Root;
        if (fetchElement == null || !string.Equals(fetchElement.Name, "fetch", StringComparison.OrdinalIgnoreCase))
        {
            await WriteAsync(outputStream, "// Unable to generate code: FetchXML does not contain a <fetch> root element.");
            return GeneratorResult.Success;
        }

        // Remove any comments, etc. Also remove <?xml ...?> declaration if present and xmlns:xsi and xsi:noNamespaceSchemaLocation attributes from the <fetch> element.
        var nodeToRemove = new List<SyntaxNode>();
        foreach (var node in docSyntax.ChildNodes)
        {
            if (node.Kind is SyntaxKind.XmlComment or SyntaxKind.XmlProcessingInstruction or SyntaxKind.XmlDeclaration)
            {
                nodeToRemove.Add(node);
            }
        }
        foreach (var node in fetchElement.AsSyntaxElement.AttributesNode)
        {
            if (node.Name.IndexOf(':') > -1)
            {
                nodeToRemove.Add(node);
            }
        }
        var cleanDocument = docSyntax.RemoveNodes(nodeToRemove, SyntaxRemoveOptions.KeepNoTrivia);

        // Reconstruct the FetchXML string from the cleaned-up syntax tree
        var fetchXml = cleanDocument.ToFullString().Trim();

        try
        {
            var model = await ParseFetchXmlAsync(docSyntax, cancellationToken);
            if (model == null)
            {
                await WriteAsync(outputStream, "// Unable to generate code: FetchXML could not be parsed.");
                return GeneratorResult.Success;
            }
            model.Raw = cleanDocument.ToFullString();


            var queryName = Path.GetFileNameWithoutExtension(inputFilePath);
            var code = @$"using Microsoft.Xrm.Sdk;
using Microsoft.Xrm.Sdk.Query;

namespace {defaultNamespace}
{{
    internal static partial class FetchQueries
    {{
        public const string {queryName} = @""{EscapeForVerbatim(fetchXml)}"";
        public static EntityCollection Query{queryName}(this IOrganizationService service) => service.RetrieveMultiple(new FetchExpression({queryName}));
    }} 
}}";
            await WriteAsync(outputStream, code);
            return GeneratorResult.Success;
        }
        catch (Exception ex)
        {
            await WriteAsync(outputStream, "// Error generating from FetchXML: " + ex.Message);
            // Return success to avoid generator infrastructure treating it as a hard failure.
            return GeneratorResult.Success;
        }
    }

    private async Task<Model.FetchQuery> ParseFetchXmlAsync(string fetchXml, CancellationToken cancellationToken)
    {
        if (string.IsNullOrWhiteSpace(fetchXml)) throw new ArgumentNullException(nameof(fetchXml));
        var parser = new FetchXmlParser();
        return await parser.ParseAsync(fetchXml, cancellationToken).ConfigureAwait(false);
    }

    private async Task<Model.FetchQuery> ParseFetchXmlAsync(XmlDocumentSyntax docSyntax, CancellationToken cancellationToken)
    {
        if (docSyntax == null) throw new ArgumentNullException(nameof(docSyntax));
        var parser = new FetchXmlParser();
        return await parser.ParseAsync(docSyntax, cancellationToken).ConfigureAwait(false);
    }

    private static Task WriteAsync(Stream stream, string text)
    {
        var buffer = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false).GetBytes(text);
        return stream.WriteAsync(buffer, 0, buffer.Length);
    }

    private static string EscapeForVerbatim(string input)
    {
        if (string.IsNullOrEmpty(input)) return string.Empty;
        // In verbatim strings, we only need to double the quotes
        return input.Replace("\"", "\"\"");
    }
}
